<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>class的继承</title>
</head>

<body>
    <script>
        //class的继承
        //1.Class 可以通过extends关键字实现继承
        // class A {
        //     constructor() {
        //         this.x = 1;
        //         this.y = 2;
        //         this.name = "志豪"
        //     }
        // }
        // class B extends A {// B是A的子类
        //     constructor() {
        //         super();//super关键字，它在这里表示父类的构造函数，用来新建父类的this对象
        //         this.z = 4;
        //     }
        //     sayAge() {
        //         console.log(18);
        //     }
        // }
        // let b = new B();
        // class C extends B {
        //     constructor() {
        //         super();
        //         this.h = 4;
        //     }
        // }

        //2.Object.getPrototypeOf:方法可以用来从子类上获取父类
        // Object.getPrototypeOf(ColorPoint) === Point// true
        //可以使用这个方法判断，一个类是否继承了另一个类。

        //3.类的 prototype 属性和__proto__属性
        //3.1:子类的__proto__属性，表示构造函数的继承，总是指向父类。
        //子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。
        // class A {
        // }
        // class B extends A {
        // }
        // B.__proto__ === A // true
        // B.prototype.__proto__ === A.prototype // true
        //上面代码中，子类B的__proto__属性指向父类A.
        //子类B的prototype属性的__proto__属性指向父类A的prototype属性。

        //3.2:实例的 __proto__ 属性:子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。
        // var p1 = new Point(2, 3);
        // var p2 = new ColorPoint(2, 3, 'red');
        // p2.__proto__ === p1.__proto__ // false
        // p2.__proto__.__proto__ === p1.__proto__ // true
        //因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。
        // p2.__proto__.__proto__.printName = function () {
        //     console.log('Ha');
        // };
        // p1.printName() // "Ha"

        //4.super关键字,既可以当作函数使用，也可以当作对象使用。
        //4.1:第一种情况：super作为函数调用时，代表父类的构造函数。
        //ES6 要求，子类的构造函数必须执行一次super函数。
        // class A { }
        // class B extends A {
        //     constructor() {
        //         super();
        //     }
        // }

        //4.2:第二种情况：super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
        //4.2.1:上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。
        // class A {
        //     p() {
        //         return 2;
        //     }
        // }
        // class B extends A {
        //     constructor() {
        //         super();
        //         console.log(super.p()); // 2
        //     }
        // }
        // let b = new B();
        //4.2.2:
        // class A {
        //     constructor() {
        //         this.p = 2;
        //     }
        // }
        // class B extends A {
        //     get m() {
        //         return super.p;
        //     }
        // }
        // let b = new B();
        // b.m // undefined
        //上面代码中，p是父类A实例的属性，super.p就引用不到它。
        // class A { }
        // A.prototype.x = 2;
        // class B extends A {
        //     constructor() {
        //         super();
        //         console.log(super.x) // 2
        //     }
        // }
        // let b = new B();
        //上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。

        //4.3:注意：使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。
        // class A { }
        // class B extends A {
        //     constructor() {
        //         super();
        //         console.log(super); // 报错
        //         console.log(super.valueOf() instanceof B); // true
        //     }
        // }
        // let b = new B();

        //4.4:由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。
        // var obj = {
        //     toString() {
        //         return "MyObject: " + super.toString();
        //     }
        // };
        // obj.toString(); // MyObject: [object Object]

        //5.Mixin 模式的实现 ：指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。
        // const a = {
        //     a: 'a'
        // };
        // const b = {
        //     b: 'b'
        // };
        // const c = { ...a, ...b }; // {a: 'a', b: 'b'}
        //上面代码中，c对象是a对象和b对象的合成，具有两者的接口。

        //下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。
        function mix(...mixins) {
            class Mix {
                constructor() {
                    for (let mixin of mixins) {
                        copyProperties(this, new mixin()); // 拷贝实例属性
                    }
                }
            }
            for (let mixin of mixins) {
                copyProperties(Mix, mixin); // 拷贝静态属性
                copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
            }
            return Mix;
        }
        function copyProperties(target, source) {
            for (let key of Reflect.ownKeys(source)) {
                if (key !== 'constructor'
                    && key !== 'prototype'
                    && key !== 'name'
                ) {
                    let desc = Object.getOwnPropertyDescriptor(source, key);
                    Object.defineProperty(target, key, desc);
                }
            }
        }//上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。


    </script>
</body>

</html>