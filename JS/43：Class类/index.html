<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //Class基本语法:
        //1:ES6的class的使用方法和ES5的构造函数用法一样
        //1:1：ES5
        // function A(x, y) {
        //     this.x = x;
        //     this.y = y;
        // }
        // A.prototype.toString = function () {
        //     return `(${this.x},${this.y})`
        // }
        // let fn = new A(4, 7);
        //1.2：ES6:类的新方法可以添加在prototype对象上面。
        // class p {
        //     constructor(x, y) {
        //         this.x = x;
        //         this.y = y;
        //     }
        //     toString() {
        //         return '(' + this.x + ', ' + this.y + ')';
        //     }
        //     getName() {
        //         return this.name;
        //     }
        // }
        //:1.3：Object.assign方法可以很方便地一次向类添加多个方法。
        // Object.assign(P.prototype, {
        //     toString() { },
        //     toValue() { }
        // })
        // let f = new p(4, 7);

        //2.1：ES6,类的内部所有定义的方法，都是不可枚举的（non-enumerable）
        // class Point {
        //     constructor(x, y) {
        //         // ...
        //     }
        //     toString() {
        //         // ...
        //     }
        // }
        // Object.keys(Point.prototype);// []
        // Object.getOwnPropertyNames(Point.prototype);// ["constructor","toString"]
        //2.2：ES5 的写法，toString方法就是可枚举的
        // var Point = function (x, y) {
        //     this.x = x;
        //     this.y = y;
        // };
        // Point.prototype.toString = function () {
        //     // ...
        // };
        // let P = new Point(2, 4);
        // Object.keys(Point.prototype);// ["toString"]
        // Object.getOwnPropertyNames(Point.prototype);// ["constructor","toString"]
        // for (let i in P) { console.log(i) }//遍历 结果：x，y，toString

        //3.1：Class表达式：与函数一样，类也可以使用表达式的形式定义
        // const MyClass = class Me {
        //     getClassName() {
        //         return Me.name;
        //     }
        // };
        // let inst = new MyClass();
        // inst.getClassName() // Me
        // Me.name // ReferenceError: Me is not defined
        //3.2：采用 Class 表达式，可以写出立即执行的 Class
        // let person = new class {
        //     constructor(name) {
        //         this.name = name;
        //     }
        //     sayName() {
        //         console.log(this.name);
        //     }
        // }('张三');
        // person.sayName(); // "张三"

        //4：注意点
        //4.1：类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式
        //只要你的代码写在类或模块之中，就只有严格模式可用
        //4.2.1：不存在提升：类不存在变量提升（hoist），这一点与 ES5 完全不同，ES6 不会把类的声明提升到代码头部
        // new Foo(); // ReferenceError
        // class Foo { }
        //4.2.2：下面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。
        // {
        //     let Foo = class { };
        //     class Bar extends Foo {
        //     }
        // }
        //4.2.3：name 属性：由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。
        // class Point { }
        // Point.name // "Point"
        //4.2.4:this的指向:
        //类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错
        // class Logger {
        //     printName(name = 'there') {
        //         this.print(`Hello ${name}`);
        //     }

        //     print(text) {
        //         console.log(text);
        //     }
        // }

        // const logger = new Logger();
        // const { printName } = logger;
        // printName(); // TypeError: Cannot read property 'print' of undefined
        //解决方法：箭头函数，箭头函数内部的this总是指向定义时所在的对象。
        // class Obj {
        //     constructor() {
        //         this.getThis = () => this;
        //     }
        // }
        // const myObj = new Obj();
        // myObj.getThis() === myObj // true

        //5.静态方法：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。
        //5.1如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
        // class Foo {
        //     static classMethod() {
        //         return 'hello';
        //     }
        // }
        // Foo.classMethod() // 'hello'
        // var foo = new Foo();
        // foo.classMethod()// TypeError: foo.classMethod is not a function
        //5.2注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。
        // class Foo {
        //     static bar() {
        //         this.baz();
        //     }
        //     static baz() {
        //         console.log('hello');
        //     }
        //     baz() {
        //         console.log('world');
        //     }
        // }
        // Foo.bar() // hello
        //5.3:父类的静态方法，可以被子类继承。
        // class Foo {
        //     static classMethod() {
        //         return 'hello';
        //     }
        // }
        // class Bar extends Foo {
        // }
        // Bar.classMethod() // 'hello'
        //5.4:静态方法也是可以从super对象上调用的。
        // class Foo {
        //     static classMethod() {
        //         return 'hello';
        //     }
        // }
        // class Bar extends Foo {
        //     static classMethod() {
        //         return super.classMethod() + ', too';
        //     }
        // }
        // Bar.classMethod() // "hello, too"

        //6，class的私有方法和私有属性
        //6.1：目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。
        // class IncreasingCounter {
        //     #count = 0;
        //     get value() {
        //         console.log('Getting the current value!');
        //         return this.#count;
        //     }
        //     increment() {
        //         this.#count++;
        //     }
        // }//上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。
        //6.2：这种写法不仅可以写私有属性，还可以用来写私有方法。
        // class Foo {
        //     #a;
        //     #b;
        //     constructor(a, b) {
        //         this.#a = a;
        //         this.#b = b;
        //     }
        //     #sum() {
        //         return this.#a + this.#b;
        //     }
        //     printSum() {
        //         console.log(this.#sum());
        //     }
        // } //上面代码中，#sum()就是一个私有方法。
        //6.3:私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法。
        // class FakeMath {
        //     static PI = 22 / 7;
        //     static #totallyRandomNumber = 4;
        //     static #computeRandomNumber() {
        //         return FakeMath.#totallyRandomNumber;
        //     }
        //     static random() {
        //         console.log('I heard you like random numbers…')
        //         return FakeMath.#computeRandomNumber();
        //     }
        // }
        // FakeMath.PI // 3.142857142857143
        // FakeMath.random()
        // // I heard you like random numbers…
        // // 4
        // FakeMath.#totallyRandomNumber // 报错
        // FakeMath.#computeRandomNumber() // 报错

        //7：构造函数新属性:new.target 属性:这个属性可以用来确定构造函数是怎么调用的
        // function Person(name) {
        //     if (new.target !== undefined) {
        //         this.name = name;
        //     } else {
        //         throw new Error('必须使用 new 命令生成实例');
        //     }
        // }
        // 另一种写法
        // function Person(name) {
        //     if (new.target === Person) {
        //         this.name = name;
        //     } else {
        //         throw new Error('必须使用 new 命令生成实例');
        //     }
        // }
        // var person = new Person('张三'); // 正确
        // var notAPerson = Person.call(person, '张三');  // 报错(必须使用new命令生成实例)

    </script>
</body>

</html>