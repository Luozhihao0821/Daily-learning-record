<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator</title>
</head>

<body>
    <script>
        //Generator 函数的语法和 API
        //1.含义：形式上，Generator 函数是一个普通函数，但是有两个特征。
        //一是，function关键字与函数名之间有一个星号*；
        //二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
        function* helloWorldGenerator() {
            yield 'hello';
            yield 'world';
            return 'ending';
        }
        var hw = helloWorldGenerator();
        //下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。执行到return是直接终结函数，后面不再执行。
        hw.next();//{value: "hello", done: false}
        hw.next();//{value: "world", done: false}
        hw.next();//{value: "ending", done: true}
        hw.next();//{value: undefined, done: true}

        //2.yield 表达式
        //由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。
        //2.1：运行逻辑：
        // （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
        // （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
        // （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
        // （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。

        // 2.2.1:yield 必须用在Generator函数里面，其他地方会报错。
        // 2.2.2:yield表达式如果用在另一个表达式之中，必须放在圆括号里面。
        function* demo() {
            console.log('Hello' + yield); // SyntaxError
            console.log('Hello' + yield 123); // SyntaxError

            console.log('Hello' + (yield)); // OK
            console.log('Hello' + (yield 123)); // OK
        }
        // 2.2.3:yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。
        function* demo() {
            foo(yield 'a', yield 'b'); // OK
            let input = yield; // OK
        }

        //3.与 Iterator 接口的关系
        //3.1:由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
        var myIterable = {};
        myIterable[Symbol.iterator] = function* () {
            yield 1;
            yield 2;
            yield 3;
        };
        [...myIterable] // [1, 2, 3]
        //3.2:Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。
        function* gen() {
            // some code
        }
        var g = gen();
        g[Symbol.iterator]() === g// true

        //4.next 方法的参数
        //yield表达式本身没有返回值，或者说总是返回undefined。
        //next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
        function* f() {
            for (var i = 0; true; i++) {
                var reset = yield i;
                if (reset) { i = -1; }
            }
        }
        var g = f();
        g.next() // { value: 0, done: false }
        g.next() // { value: 1, done: false }
        g.next(true) // { value: 0, done: false }

        //5.for...of 循环
        //5.1:for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。
        function* foo() {
            yield 1;
            yield 2;
            yield 3;
            yield 4;
            yield 5;
            return 6;
        }
        for (let v of foo()) {
            console.log(v);
        }// 1 2 3 4 5
        //一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。

        //5.2:利用 Generator 函数和for...of循环，实现斐波那契数列的例子。
        function* fibonacci() {
            let [prev, curr] = [0, 1];
            for (; ;) {
                yield curr;
                [prev, curr] = [curr, prev + curr];
            }
        }
        for (let n of fibonacci()) {
            if (n > 1000) break;
            console.log(n);
        }

        //5.3:利用for...of循环，可以写出遍历任意对象（object）的方法。
        function* objectEntries(obj) {
            let propKeys = Reflect.ownKeys(obj);

            for (let propKey of propKeys) {
                yield [propKey, obj[propKey]];
            }
        }
        let jane = { first: 'Jane', last: 'Doe' };
        for (let [key, value] of objectEntries(jane)) {
            console.log(`${key}: ${value}`);
        }
        // first: Jane
        // last: Doe

        //5.4:扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。
        //这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。
        function* numbers() {
            yield 1
            yield 2
            return 3
            yield 4
        }
        // 扩展运算符
        [...numbers()] // [1, 2]
        // Array.from 方法
        Array.from(numbers()) // [1, 2]
        // 解构赋值
        let [x, y] = numbers();
        x // 1
        y // 2
        // for...of 循环
        for (let n of numbers()) {
            console.log(n)
        }
        // 1
        // 2

        //6.函数的报错处理try,catch语句
        //6.1:Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。
        var g = function* () {
            try {
                yield;
            } catch (e) {
                console.log('内部捕获', e);
            }
        };
        var i = g();
        i.next();
        try {
            i.throw('a');
            i.throw('b');
        } catch (e) {
            console.log('外部捕获', e);
        }
        // 内部捕获 a
        // 外部捕获 b

        //6.2:throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。
        var g = function* () {
            try {
                yield;
            } catch (e) {
                console.log(e);
            }
        };
        var i = g();
        i.next();
        i.throw(new Error('出错了！'));
        // Error: 出错了！(…)

    </script>
</body>

</html>